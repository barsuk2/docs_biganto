#%% md

#### Тестирование- общие понятия
Тестировщие занимается тестированием
ТЕТесчтирование - испытание ПО, что все требования соблюдены.

Автоматизированное тестирование ПО включает в себя:
1. Функциональное тестирование — это тестирование ПО в целях проверки реализуемости функциональных требований, то есть способности ПО в определённых условиях решать задачи, нужные пользователям.
Проверяем функционал - РАботет ли , соглассное описанию
2. Нагрузочное тестирование - испытание ПО в условиях пргнозируемой нормальной нагрузки. Под величиной нормальной нагрузки понимается количество запросов к системе, которое она должна успевать орабатывать, не превышая определенное исходными методами время отклика.

3.Регрессионное тестирование - гренаправленных на обнаружение ошибок в уже протестированных участках исходного кода. Такие ошибки — когда после внесения изменений в программу перестаёт работать то, что должно было продолжать работать, — называют регрессионными ошибками (англ. regression bugs).

#%% md

Виды Автоматического тестирования
1. Выполняет авто тестирование
2. Выполняет автоматические процессы тестирования

авто тестирование выполняет
1. Функциональное тестиров-е
2. Юзабилити (полность нельзя полагаться)
3. Нагрузочное

авто тест обеспечивает

1. Багтракинг
Система отслеживания ошибок (англ. bug tracking system) — прикладная программа, разработанная с целью помочь разработчикам программного обеспечения (программистам, тестировщикам и др.) учитывать и контролировать ошибки и неполадки, найденные в программах..
2. Система управления требованиями
3. Система автоматизации процессов

#%% md

Методы черного и белого ящика при автоматизации
1. Белый ящик - ЕСТЬ доступ к коду.
1. Черный ящик - НЕТ доступ к коду

#%% md

ДЗ-1
1. Составить список автоматизированных функциональных тестов
для тестирования приложения «Калькулятор».

РЕШЕНИЕ
Список функциональных тестов для приложения "Калькулятор"
1. Проверка строки HEAD
1.1 Проверка переключения режимов калькулятора
1.2 Проверка вызова МЕНЮ
1.4 Проверка сворачивания активного окна
1.5 Проверка разворачивания активного окна на весь экран
1.5 Проверка закрытия активного окна

2. Подготовить сценарии для проведения автоматизированного
функционального тестирования в "Калькулятор" в строке HEAD.

Тест-кейс
№++++Действие++++Результат
1.1 Проверка переключения режимов калькулятора
1.++++Выбор режима "Расширенный режим"++++Отображено окно расширенного калькулятора
2.++++Выбор режима "Финансовый режим"++++Отображено окно Финансовый режим

#%% md

Стратегия автоматического тестирования.
План проведения работ по тестированию

общая - цели тестирования
проектная - методика тестирования модуля

#%% md
При заходе на предприятия выясняем
ЧТО ТЕСТИРУЕМ.
1. Функциональность
2. Производительность
3. Надежность
4. Удобство (юзабилити)
5. Переносимость
6. Сопроаождаемость

Как когда и как часто тестируем.
#%% md
Пирамида тестирования
Чем выше тест, тем он медленнее и дороже в создании и поддержке


1. Модульные [UNIT] тесты проверяют работу отдельно взятых модулей — функций, классов, моделей, контроллеров — кирпичиков, из которых построено приложение. Модульные тесты выполняют проверки за миллисекунды, потому что тестируют модуль в отрыве от остального приложения.

2.Сервисные тесты [servise test] — среднее между интеграционными и модульными. Их задача — проверить функционал, который нельзя уверенно протестировать модульными тестами, а интеграционными тестировать «слишком жирно».

3. Интеграционные тесты проверяют приложение целиком, когда все модули в сборе. Их задача — убедиться, что модули правильно соединены друг с другом. Кроме того, ими проверяют те части приложения, которые не имеют права сломаться: биллинг, регистрацию, оформление заказа. Интеграционные тесты длятся секунды, а иногда и минуты: запускаем приложение, загружаем его в браузер или эмулятор и «прокликиваем» сценарии.

#%% md

Инструменты авто тестирования

1. Подготовка тестового окружения
2. Генерация тестовых данных
3. Запуск тестов
4. Очистка окружения после тестирования
5. Анализ результатов

#%% md
Технологический стек автотетсрования
1. Контроль версий [git]
VCS version control systems 

2. IDE (Pycharm) 

3. Система упралением тестированием [TestRail, ситичко]
3.1 Написание и хранение тестовых сценариев, 
3.2 Формирование тест планов
3.3 Интеграция  CI (интеграция отдельных кусочков кода приложения между собой.)
3.4 Визулизация результатов тестов

Sitechco.ru
sitechco.ru
Sitechco — онлайн-сервис, в котором вы можете вести свои чек-листы, взаимодействовать по ним с командой, хранить результаты, просматривать...
4. Сервер непрерывной интеграции
Анализ кода статическими анализаторами
Сборка кода
запуск тестов
История
Отчеты
5. Сборщик (не наш)
1. Компиляция
2. Сборка

6. Тестовый фреймворк [pytest]
6.1. Формирование тестового набора
6.2. Управление запуском тестов
6.3. Параллелизация
6.4. Группирование
6.5. Сортировка
6.6. Создание фикстур для тестов (декоратор )
6.7. Очистка


7. Тесты
8. драйвера - способы взаимодействия с тестируемой системой

9. Хранение и анализ данных
9.1. В виде фалов
9.2. В Базах данных

#%% md

### PYTEST

1. Тестовый фреймврк - совокупность методик, подходов и инструментов для написания тестов

2. Можно ли писать без фреймворка - Да

3. Почему pytest - многоцелевой( можно как unit, как system ) и фунциональный, можно добавлять плагины

4.  Отличная документация

#%% md
#### Основы pytest

1. Создаем фалы и функции с префиксом test
2. Создаем классы с префиксом Test

#### 
Запуск
pytest  - для всего проекта
pytest 0_pytest_intro/ - для папки
pytest 0_pytest_intro/test_pytest_intro.py - для модуля
pytest 0_pytest_intro/test_pytest_intro.py::test_one -для функции

Флаг -v / -q управления подробностью вывода
-v - полный
-q - краткий

Флаг -s позволяет отображать print’ы
pytest 0_pytest_intro -q -s

Флаг -x / --maxfail=n Остановить тесты после 1-го или n-го падения

ДЛЯ ЧЕГО ИСПОЛЬЗУЕТСЯ
unit-test должен проходить без ошибок, если ошибка, то нужно исправлять


Флаг --collect-only Собрать информацию о тестах

Флаг --lf запустить только последние упавшие

Флаг Посмотреть все другие параметры -h


#%% md
#### fixtures

Используется для передачи в тестируемую функцию (класс) параметров
>@pytest.fixture
def first_fixture():
    print("\nPrint from 'first_fixture'")

>def test_one(first_fixture):
    pass

conftest.py -файл для фикстур
импорт не требуется. Если не находит в локальном conftest, то ищет в корневом

#%% md
#### fixtures scope
уровни фикстур
задать уровень фикстуры (scope). Возможные значения “function”, “cls”, “module”, “session”. Значение по умолчанию = “function”.
session fixture!
module fixture!
class fixture!
function fixture!
function fixture!
class fixture!
module fixture!
session fixture!

#%% md
#### autouse

параметр autouse передается всегда во все фикстуры
НЕ ИСПОЛЬЗОВАТЬ


#%% md
#### объект request
содержит доп информацию 
request.node - что запустили <Function test_one>
request.scope - уровень scope function
request.cls - инфа по классу <class 'test_1_fixtures_request.TestClass'>
request.module -инфа по модулю <module 'test_1_fixtures_request' from '/home/egor/python_qa_pytest-master/4_fixtures_request_object_finalizer/test_1_fixtures_request.py'>
request.addfinalizer - вызов функции при закрытии фикстуры. Так же можно через [yield]

фиксуры могут быть вложенными друг в друга.
вызывется ПЕРВЫЙ вызов фикстуры
>первая открвает БД , второя изменяет функция выполняется , вторая закрывется, Первая закрывется

#%% md
#### Получение данных из фикстуры
@pytest.fixture
def fixture_return_rnd_number():
    return random.randint(1, 100)

в тесте используется assert для проверки значения из фиктуры
def test_the_number(fixture_return_rnd_number):
    assert fixture_return_rnd_number == 20

#%% md

### Праметризация
уровень фикстур
@pytest.fixture(params=[11, 12, 13, 14])
def fixture_with_params(request):
    return request.param

уровень теста
@pytest.mark.parametrize("test_input", [1, 2, 3])
def test_one_2(test_input):
    print(test_input)

#%% md
### Тестирование api

#### Аргументы коммандной строки

###модуль argparse
создание параметизации в еомандной строке

передача параметров в pytest
параметризация 

### API

В случае веб-приложения также часто проверяется не вызов функции, а результат какого-то HTTP-запроса, который мы внутри фласка можем сделать сами, см. tests/test_users.py, функция client(): там создаётся контекст приложения с конфигом config.test.py, где прописана тестовая база данных (пустая), в этой базе стираются все таблицы, затем они создаются заново из моделей (db.create_all()), затем таблица users инициализируется тестовыми данными, и возвращается app.test_client(), который является экземпляром класса, позволяющего делать HTTP-запросы к нашему серверу веб-приложения.